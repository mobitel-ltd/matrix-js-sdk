{"version":3,"sources":["../../../src/crypto/store/memory-crypto-store.js"],"names":["MemoryCryptoStore","_outgoingRoomKeyRequests","_account","_sessions","_inboundGroupSessions","_deviceData","_rooms","Promise","resolve","request","requestBody","try","existing","_getOutgoingRoomKeyRequest","logger","log","room_id","session_id","push","utils","deepCompare","wantedStates","req","state","requestId","expectedState","updates","warn","i","length","splice","txn","func","newData","deviceKey","sessionId","deviceSessions","session","undefined","senderCurve25519Key","key","senderKey","substr","sessionData","k","deviceData","roomId","roomInfo","mode","stores"],"mappings":"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","file":"memory-crypto-store.js","sourcesContent":["/*\nCopyright 2017 Vector Creations Ltd\nCopyright 2018 New Vector Ltd\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport Promise from 'bluebird';\n\nimport logger from '../../logger';\nimport utils from '../../utils';\n\n/**\n * Internal module. in-memory storage for e2e.\n *\n * @module\n */\n\n/**\n * @implements {module:crypto/store/base~CryptoStore}\n */\nexport default class MemoryCryptoStore {\n    constructor() {\n        this._outgoingRoomKeyRequests = [];\n        this._account = null;\n\n        // Map of {devicekey -> {sessionId -> session pickle}}\n        this._sessions = {};\n        // Map of {senderCurve25519Key+'/'+sessionId -> session data object}\n        this._inboundGroupSessions = {};\n        // Opaque device data object\n        this._deviceData = null;\n        // roomId -> Opaque roomInfo object\n        this._rooms = {};\n    }\n\n    /**\n     * Delete all data from this store.\n     *\n     * @returns {Promise} Promise which resolves when the store has been cleared.\n     */\n    deleteAllData() {\n        return Promise.resolve();\n    }\n\n    /**\n     * Look for an existing outgoing room key request, and if none is found,\n     * add a new one\n     *\n     * @param {module:crypto/store/base~OutgoingRoomKeyRequest} request\n     *\n     * @returns {Promise} resolves to\n     *    {@link module:crypto/store/base~OutgoingRoomKeyRequest}: either the\n     *    same instance as passed in, or the existing one.\n     */\n    getOrAddOutgoingRoomKeyRequest(request) {\n        const requestBody = request.requestBody;\n\n        return Promise.try(() => {\n            // first see if we already have an entry for this request.\n            const existing = this._getOutgoingRoomKeyRequest(requestBody);\n\n            if (existing) {\n                // this entry matches the request - return it.\n                logger.log(\n                    `already have key request outstanding for ` +\n                    `${requestBody.room_id} / ${requestBody.session_id}: ` +\n                    `not sending another`,\n                );\n                return existing;\n            }\n\n            // we got to the end of the list without finding a match\n            // - add the new request.\n            logger.log(\n                `enqueueing key request for ${requestBody.room_id} / ` +\n                requestBody.session_id,\n            );\n            this._outgoingRoomKeyRequests.push(request);\n            return request;\n        });\n    }\n\n    /**\n     * Look for an existing room key request\n     *\n     * @param {module:crypto~RoomKeyRequestBody} requestBody\n     *    existing request to look for\n     *\n     * @return {Promise} resolves to the matching\n     *    {@link module:crypto/store/base~OutgoingRoomKeyRequest}, or null if\n     *    not found\n     */\n    getOutgoingRoomKeyRequest(requestBody) {\n        return Promise.resolve(this._getOutgoingRoomKeyRequest(requestBody));\n    }\n\n    /**\n     * Looks for existing room key request, and returns the result synchronously.\n     *\n     * @internal\n     *\n     * @param {module:crypto~RoomKeyRequestBody} requestBody\n     *    existing request to look for\n     *\n     * @return {module:crypto/store/base~OutgoingRoomKeyRequest?}\n     *    the matching request, or null if not found\n     */\n    _getOutgoingRoomKeyRequest(requestBody) {\n        for (const existing of this._outgoingRoomKeyRequests) {\n            if (utils.deepCompare(existing.requestBody, requestBody)) {\n                return existing;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Look for room key requests by state\n     *\n     * @param {Array<Number>} wantedStates list of acceptable states\n     *\n     * @return {Promise} resolves to the a\n     *    {@link module:crypto/store/base~OutgoingRoomKeyRequest}, or null if\n     *    there are no pending requests in those states\n     */\n    getOutgoingRoomKeyRequestByState(wantedStates) {\n        for (const req of this._outgoingRoomKeyRequests) {\n            for (const state of wantedStates) {\n                if (req.state === state) {\n                    return Promise.resolve(req);\n                }\n            }\n        }\n        return Promise.resolve(null);\n    }\n\n    /**\n     * Look for an existing room key request by id and state, and update it if\n     * found\n     *\n     * @param {string} requestId      ID of request to update\n     * @param {number} expectedState  state we expect to find the request in\n     * @param {Object} updates        name/value map of updates to apply\n     *\n     * @returns {Promise} resolves to\n     *    {@link module:crypto/store/base~OutgoingRoomKeyRequest}\n     *    updated request, or null if no matching row was found\n     */\n    updateOutgoingRoomKeyRequest(requestId, expectedState, updates) {\n        for (const req of this._outgoingRoomKeyRequests) {\n            if (req.requestId !== requestId) {\n                continue;\n            }\n\n            if (req.state != expectedState) {\n                logger.warn(\n                    `Cannot update room key request from ${expectedState} ` +\n                    `as it was already updated to ${req.state}`,\n                );\n                return Promise.resolve(null);\n            }\n            Object.assign(req, updates);\n            return Promise.resolve(req);\n        }\n\n        return Promise.resolve(null);\n    }\n\n    /**\n     * Look for an existing room key request by id and state, and delete it if\n     * found\n     *\n     * @param {string} requestId      ID of request to update\n     * @param {number} expectedState  state we expect to find the request in\n     *\n     * @returns {Promise} resolves once the operation is completed\n     */\n    deleteOutgoingRoomKeyRequest(requestId, expectedState) {\n        for (let i = 0; i < this._outgoingRoomKeyRequests.length; i++) {\n            const req = this._outgoingRoomKeyRequests[i];\n\n            if (req.requestId !== requestId) {\n                continue;\n            }\n\n            if (req.state != expectedState) {\n                logger.warn(\n                    `Cannot delete room key request in state ${req.state} `\n                    + `(expected ${expectedState})`,\n                );\n                return Promise.resolve(null);\n            }\n\n            this._outgoingRoomKeyRequests.splice(i, 1);\n            return Promise.resolve(req);\n        }\n\n        return Promise.resolve(null);\n    }\n\n    // Olm Account\n\n    getAccount(txn, func) {\n        func(this._account);\n    }\n\n    storeAccount(txn, newData) {\n        this._account = newData;\n    }\n\n    // Olm Sessions\n\n    countEndToEndSessions(txn, func) {\n        return Object.keys(this._sessions).length;\n    }\n\n    getEndToEndSession(deviceKey, sessionId, txn, func) {\n        const deviceSessions = this._sessions[deviceKey] || {};\n        func(deviceSessions[sessionId] || null);\n    }\n\n    getEndToEndSessions(deviceKey, txn, func) {\n        func(this._sessions[deviceKey] || {});\n    }\n\n    storeEndToEndSession(deviceKey, sessionId, session, txn) {\n        let deviceSessions = this._sessions[deviceKey];\n        if (deviceSessions === undefined) {\n            deviceSessions = {};\n            this._sessions[deviceKey] = deviceSessions;\n        }\n        deviceSessions[sessionId] = session;\n    }\n\n    // Inbound Group Sessions\n\n    getEndToEndInboundGroupSession(senderCurve25519Key, sessionId, txn, func) {\n        func(this._inboundGroupSessions[senderCurve25519Key+'/'+sessionId] || null);\n    }\n\n    getAllEndToEndInboundGroupSessions(txn, func) {\n        for (const key of Object.keys(this._inboundGroupSessions)) {\n            // we can't use split, as the components we are trying to split out\n            // might themselves contain '/' characters. We rely on the\n            // senderKey being a (32-byte) curve25519 key, base64-encoded\n            // (hence 43 characters long).\n\n            func({\n                senderKey: key.substr(0, 43),\n                sessionId: key.substr(44),\n                sessionData: this._inboundGroupSessions[key],\n            });\n        }\n        func(null);\n    }\n\n    addEndToEndInboundGroupSession(senderCurve25519Key, sessionId, sessionData, txn) {\n        const k = senderCurve25519Key+'/'+sessionId;\n        if (this._inboundGroupSessions[k] === undefined) {\n            this._inboundGroupSessions[k] = sessionData;\n        }\n    }\n\n    storeEndToEndInboundGroupSession(senderCurve25519Key, sessionId, sessionData, txn) {\n        this._inboundGroupSessions[senderCurve25519Key+'/'+sessionId] = sessionData;\n    }\n\n    // Device Data\n\n    getEndToEndDeviceData(txn, func) {\n        func(this._deviceData);\n    }\n\n    storeEndToEndDeviceData(deviceData, txn) {\n        this._deviceData = deviceData;\n    }\n\n    // E2E rooms\n\n    storeEndToEndRoom(roomId, roomInfo, txn) {\n        this._rooms[roomId] = roomInfo;\n    }\n\n    getEndToEndRooms(txn, func) {\n        func(this._rooms);\n    }\n\n    doTxn(mode, stores, func) {\n        return Promise.resolve(func(null));\n    }\n}\n"]}